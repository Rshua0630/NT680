//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "md_api.h"
#include "FileSysTsk.h"
#include "ImageApp_Movie.h"
#if (MOVIE_MAPPING_MULTIREC == ENABLE)
#include "ImageApp_MovieMulti.h"
#endif
#include "ImageApp_Photo.h" //for NVTEVT_CALLBACK, NVTEVT_CB_ZOOM, NVTEVT_ALGMSG_PREVIEW_STABLE
#if (CALIBRATION_FUNC == ENABLE)
#include "EngineerMode.h"
#include "calibration_item.h"
#endif
#include "DxOutput.h"
#include    "stdio.h"
#include    "GPS.h"

#if USE_FILEDB
#include "FileDB.h"
#include "NameRule_FileDB.h"
#endif
#include "UIFlow.h"
#if !defined(_GSensor_None_)
#include "GSensor.h"
#endif
#include "display.h"

#if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
#include "mp4log.h"
#endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
#include "alg_UIFlowWndMovie.h"
#include "alg_MovieExe.h"
#include "media_def.h"
#include "MovieInterface.h"


#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
//#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      // *=All
#include "DebugModule.h"

//#NT#2016/09/29#KCHong -begin
//#NT#The GPS related variables should not depend on ADAS.
#if (GPS_FUNCTION == ENABLE)
extern FLOAT g_CurSpeed;
extern BOOL g_GPSLinked;
extern BOOL g_GPSStatus;
#endif
//#NT#2016/09/29#KCHong -end

//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
extern BOOL     gb3DNROut;
#endif
//#NT#2016/09/20#Bob Huang -end

//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *, UINT32, UINT32 *);        //#NT#2016/03/25#New ADAS#KCHong
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *, UINT32, UINT32 *);
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *, UINT32, UINT32 *);
//#NT#2016/07/20#Brain Yen -end
INT32 UIFlowWndMovie_OnOverTime(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBackgroundDone(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_UPDATE_INFO, UIFlowWndMovie_OnUpdateInfo)
#if defined(_KEY_METHOD_4KEY_)
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndMovie_OnKeyDown)    // Down Key
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndMovie_OnKeyNext)    // OK Key
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndMovie_OnKeySelect)   // REC key
#else
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndMovie_OnKeyNext)       // Right Key
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndMovie_OnKeySelect)   // Enter key
#endif
EVENT_ITEM(NVTEVT_KEY_MENU, UIFlowWndMovie_OnKeyMenu)
//EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN, UIFlowWndMovie_OnKeyDown)
//EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
//EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN, UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT, UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP, UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK, UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY, UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW, UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE, UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH, UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC, UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME, UIFlowWndMovie_OnOverTime) //file in BsMuxer not biggrer than 30mins, so callback BSMUXER_CBEVENT_OVERTIME to project, for re-rec
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL, UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR, UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW, UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL, UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_EMR_COMPLETED, UIFlowWndMovie_OnEMRCompleted)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK, UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG, UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM, UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT, UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER, UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug, UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug, UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1, UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_CB_ADAS_SHOWALARM, UIFlowWndMovie_OnADASShowAlarm)      //#NT#2016/03/25#New ADAS#KCHong
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
EVENT_ITEM(NVTEVT_KEY_CALIBRATION, UIFlowWndMovie_OnKeyCalibration)
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
EVENT_ITEM(NVTEVT_CB_DDD_SHOWALARM, UIFlowWndMovie_OnDDDShowAlarm)
//#NT#2016/07/20#Brain Yen -end
EVENT_ITEM(NVTEVT_BACKGROUND_DONE, UIFlowWndMovie_OnBackgroundDone)
EVENT_END

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)

//-----------------------------------------------------------------------------------------
static BOOL    g_uiRecordIngMotionDet = TRUE;
#if (_ADAS_FUNC_ == ENABLE)
UINT32 g_uiAdasAlertSecCnt = 0;
#endif  // #if (_ADAS_FUNC_ == ENABLE)
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32  g_UIStopRecTimerID = NULL_TIMER;
static UINT32  g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32  g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata = {0};
#if MOVIE_DDD_FUNC
static char strTmp[50] = {0};
#endif
static UINT32 g_uiRecStopTimerCnt     = 0;

#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
	SDCFDIRINFO dirinfo;
	char   path[DCF_FULL_FILE_PATH_LEN];
	UINT32 uiMaxFolderID, uiPrevMaxFolderID;
	UINT32 uiStrlen;
	BOOL ret;


	uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
// check if folder has file
	ret = DCF_GetDirInfo(uiMaxFolderID, &dirinfo);
	if (ret) {
		while (dirinfo.uiNumOfDcfObj == 0) {
			DCF_GetDirPath(uiMaxFolderID, path);
			uiStrlen = strlen(path);
			path[uiStrlen - 1] = '\0';
			if (FileSys_DeleteDir(path) != FST_STA_OK) {
				debug_msg("FileSys_DeleteDir failed\r\n");
			}

			DCF_Refresh();

			uiPrevMaxFolderID = uiMaxFolderID;
			// search another Max Empty folder ID
			uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

			// break if getting max folder id is always same
			if (uiPrevMaxFolderID == uiMaxFolderID) {
				break;
			}
			// check if folder has file
			ret = DCF_GetDirInfo(uiMaxFolderID, &dirinfo);

			if (ret == FALSE) {
				break;
			}
		}
	}
}
#endif

INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiKeyAct;
	UINT32 uiState;
	BOOL   CheckStorageErr = FALSE;
	BOOL bBK_StopRec = FALSE;

	// flush key event first
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

	// if HDMI is inserted, DRAM size is not enough for movie recording
	#if 0
	if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P50 ||
		UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_3840x2160P30 ||
		UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24) {
		if (KeyScan_GetPlugDev() == PLUG_HDMI) {
			return NVTEVT_CONSUME;
		}
	}
    #endif

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
		if (System_GetState(SYS_STATE_CARD)  == CARD_REMOVED) {
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	} else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL) {
		if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) { // card lock
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}

		if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) { // card insert
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	}

	if (paramNum >= 3) {
		uiState = paramArray[2];
	} else {
		uiState = 0;
	}

	uiKeyAct = paramNum ? paramArray[0] : 0;

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		//#NT#2016/03/07#KCHong -begin
		//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		if ((MovieTLLPR_Process(TIMELAPSE_FROM_UI) & TL_FLOW_MASK) == TL_FLOW_LPR) {   // TimelapseLPR module will handle recording process
// For TimelapseLPR OSD display test
			UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
			break;
		}
#endif
//#NT#2016/03/07#KCHong -end

		switch (gMovData.State) {
		case MOV_ST_VIEW:
//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
			if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD || gb3DNROut)
#else
			if (1)//MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD)
#endif
//#NT#2016/09/20#Bob Huang -end
			{
				gMovData.State = MOV_ST_REC;
#if 1
				if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
//#NT#2015/08/05#KS Hung -begin
//#NT#Even if the DCIM folder is not exist, FileSys_ScanDir stiil return FST_STA_OK.
//#NT#When the card is full and it sets cyclic record, it still can't record.
//#NT#MediaRec library will automatically delete the files of Car DV folder.
//#NT#if the files can't be deleted, it will have LOOPREC_FULL event in the callback.
					if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF) {
						CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
					} else {
						CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
					}
//#NT#2015/08/05#KS Hung -end

					if (CheckStorageErr == TRUE) {
						gMovData.State = MOV_ST_WARNING_MENU;
						gMovData.SysTimeCount = 0;
						return NVTEVT_CONSUME;
					}
				}
#endif
				if (GetBatteryLevel() == BATTERY_EXHAUSTED) {
					debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
					return NVTEVT_CONSUME;
				}

				if (FlowMovie_GetSelfTimerID() != NULL_TIMER) {
					FlowMovie_StopRecSelfTimer();
					return NVTEVT_CONSUME;
				}

				if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
					g_uiRecordIngMotionDet = TRUE;
				} else {
					g_uiRecordIngMotionDet = FALSE;
				}

				FlowMovie_StartRec();

				// start USB detect timer again
				if (g_ACPlug == TRUE) {
					SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
				}
			}
			break;

		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
#if (_ADAS_FUNC_ == ENABLE)
			g_uiAdasAlertSecCnt = 0;
#endif  // #if (_ADAS_FUNC_ == ENABLE)

			// Isiah, implement YUV merge mode of recording func.
			//if (FlowMovie_GetRecCurrTime() >= 1)
			{
				// Mask key during movie stop flow.
				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
				//Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);

#if (STOP_REC_BK == ENABLE)
				bBK_StopRec =TRUE;
				//gMovData.State = MOV_ST_WARNING_MENU;
				if (uiState == UIFlowWndMovie_Restart_Rec){
				    Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_RESTART_REC);
				}else{
				    //Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
				    if (g_UIStopRecTimerID == NULL_TIMER) {
				        g_UIStopRecTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
				    }
				    //after 1 sec then go to WaitMoment Wnd
				    g_uiRecStopTimerCnt=10;
				}
				BKG_PostEvent(NVTEVT_BKW_STOPREC_PROCESS);
#else
				bBK_StopRec =FALSE;
				FlowMovie_StopRec();
				// update ui window icon
				FlowMovie_UpdateIcons(TRUE);
#endif

				if (uiState == UIFlowWndMovie_Restart_Rec) {
					// Enable key if user pressed shutter2 key to stop recording.
					Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

#if defined(_KEY_METHOD_4KEY_)
                                if(bBK_StopRec==FALSE){
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                                }else{
                				//for WaitMoment wnd use
                                	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
                                }
#else
                                if(bBK_StopRec==FALSE){
					Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
                                }else{
					//for WaitMoment wnd use
 					Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
                                }
#endif
				} else {
					if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
						if (g_uiRecordIngMotionDet == TRUE) {
							g_uiRecordIngMotionDet = FALSE;
//#NT#2016/11/01#Adam Su -begin
//#NT#fix mantis issue 0106933
							UI_SetData(FL_MOVIE_MOTION_DET, MOVIE_MOTIONDET_OFF);
//#NT#2016/11/01#Adam Su -end
							//#NT#2018/06/28#Brain Yen -begin
							//#NT#gira: CARDV_680-75
							FlowMovie_IconHideMotionDet(&UIFlowWndMovie_Status_MotionDetCtrl);
							//#NT#2018/06/28#Brain Yen -end
						}
					}
				}
			}
			break;
		}
		break;
	}
#if defined(_KEY_METHOD_4KEY_)
	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_SHUTTER2, paramNum, paramArray);
#else
	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_SELECT, paramNum, paramArray);
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		if (0) { //((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			return NVTEVT_PASS;
		}
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
	return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
	return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
	// The same effect as Photo mode
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

	// The other settings
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);

	/* Video resolution setting must be set after other IQ settings */
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,           1,  SysGetFlag(FL_MOVIE_SIZE));

	/* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_WDR,           1,  SysGetFlag(FL_MOVIE_WDR));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_GSENSOR));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_SENSOR_ROTATE, 1,  SysGetFlag(FL_MOVIE_SENSOR_ROTATE));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_IR_CUT,        1,  SysGetFlag(FL_MOVIE_IR_CUT));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_AUTO,  1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_MANUAL, 1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_LDWS,          1,  SysGetFlag(FL_MOVIE_LDWS));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_FCW,           1,  SysGetFlag(FL_MOVIE_FCW));
	Ux_SendEvent(&UISetupObjCtrl,       NVTEVT_EXE_FREQ,                1,  SysGetFlag(FL_FREQUENCY));
#if (MOVIE_RSC == ENABLE)
	Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_RSC, 1, MOVIE_RSC_ON);
#endif
#if MOVIE_DIS_COMP_FUNC
	Ux_SendEvent(&CustomMovieObjCtrl,	MOVIE_DIS_COMP_FUNC,			1,	TRUE);
//#if MOVIE_DIS
//	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIEDIS,            1,  MOVIE_DIS_ON);
#endif
#if SHDR_FUNC
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_SHDR,                1,  MOVIE_HDR_ON);
#endif
}

static BOOL g_bDelayUpdateIcon = FALSE;

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	g_uiRecStopTimerCnt=0;
	//#NT#2016/03/07#KCHong -begin
	//#NT#Low power timelapse function, do not show OSD if boot from alarm
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
	if (MovieTLLPR_CheckHWRTStatus() == TL_HWRT_BOOT_ALARM) {
		UxCtrl_SetAllChildShow(pCtrl, FALSE);
		return NVTEVT_CONSUME;
	}
#endif
//#NT#2016/03/07#KCHong -end

	//#NT#2015/07/17#KS Hung -begin
	//#NT#For ADAS
	UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
	UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
	//#NT#2015/07/17#KS Hung -end

	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
	/* Init window key mask variables & set key and key released mask */
	g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
	g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);

#if (GSENSOR_FUNCTION == ENABLE)
	if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_640x480P240
		&& UI_GetData(FL_GSENSOR) != GSENSOR_OFF) {
		UI_SetData(FL_GSENSOR, GSENSOR_OFF);
		DBG_ERR("G-Sensor is not support on fps=240, because i2c is too busy.\r\n");
	}
//MUST open before UIFlowWndMovie_Initparam, because Initparam call GSensor_SetSensitivity.
	GSensor_open();
#endif

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
#if USE_FILEDB
		if (UI_GetData(FL_IsUseFileDB)) {
			Ux_SendEvent(&UISetupObjCtrl, NVTEVT_FILEID_RESET, 0);
		}
#endif
	}

	UIFlowWndMovie_Initparam();

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
#if(ONVIF_PROFILE_S!=ENABLE) //No File System
		if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
		}
#endif
	}

	// update g_uiRecordIngMotionDet flag
	if (gUIMotionDetTimerID == NULL_TIMER) {
		gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
	}

	if (g_uiDateTimerID == NULL_TIMER) {
		g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
	}

	// Enable Motion Detect function in starting up movie mode
	if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
		g_uiRecordIngMotionDet = TRUE;
	} else {
		g_uiRecordIngMotionDet = FALSE;
	}

	// delete empty folder
#if (USE_FILEDB==DISABLE)
	UIFlowWndMovie_DeleteEmptyFolder();
#endif

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);

#if ((POWERON_FAST_WIFI != ENABLE) && (POWERON_FAST_RECORD == ENABLE))
	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL) {
// fast record
		UINT32 paramArray[1] = {NVTEVT_KEY_PRESS};
		UIFlowWndMovie_OnExeRecord(pCtrl, 1, paramArray);
	}

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
		FlowMovie_UpdateIcons(TRUE);
	} else {
		FlowMovie_UpdateIcons(FALSE);
		UI_SetDisplayFlip(FALSE);
		g_bDelayUpdateIcon = TRUE;
	}
#else
	FlowMovie_UpdateIcons(TRUE);
#endif

#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

	UIFlowWndMovie_ALG_Clear_OSD();
	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:
		if (FlowMovie_GetRecCurrTime() <= 1) {
			Delay_DelayMs(1000);
		}
		FlowMovie_StopRec();
		Ux_SendEvent(&UIFlowWndMovieCtrl, NVTEVT_CB_MOVIE_FINISH, 0);
		break;
	}

	g_bRedLEDOn = FALSE;
	//KeyScan_TurnOffLED(KEYSCAN_LED_RED);

	if (gUIMotionDetTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&gUIMotionDetTimerID);
	}

	if (g_uiDateTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_uiDateTimerID);
	}

	if (g_UIStopRecTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIStopRecTimerID);
	}

#if (GSENSOR_FUNCTION == ENABLE)
	GSensor_close();
#endif

	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

static void UIFlowWndMovie_OnALGEnd(void)
{
	UxCtrl_SetShow(&UIFlowWndMovie_ALG_DrawCtrl, TRUE);
	/* Redraw all window OSD */
	UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
}
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (paramNum == 0) {
		return NVTEVT_CONSUME;
	}
	switch (paramArray[0]) {
	case UIAPPPHOTO_CB_ALGEND:
		UIFlowWndMovie_OnALGEnd();
		break;
	default:
		DBG_ERR("Unknown CB %d\r\n", paramArray[0]);
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// next key
	UINT32  uiKeyAct;
	UINT32  uiSoundMask;
	//UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			#if defined(_MODEL_WiFiSDV_)
			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
			return NVTEVT_CONSUME;
			#elif defined(_MODEL_FIREFLY_)
			if (UI_GetData(FL_WIFI_LINK) == WIFI_LINK_NG){
				Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
				BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
				return NVTEVT_CONSUME;
			}
			#endif

			// stope timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}

			// Enable shutter2 sound (Select key as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_ENTER;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			break;
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			#if defined(_MODEL_WiFiSDV_)
			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
			return NVTEVT_CONSUME;
			#elif defined(_MODEL_FIREFLY_)
			if (UI_GetData(FL_WIFI_LINK) == WIFI_LINK_NG){
				Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
				BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
				return NVTEVT_CONSUME;
			}
			#endif

			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL) == MOVIE_URGENT_PROTECT_MANUAL_ON) {
#if (MOVIE_MULTI_RECORD_FUNC)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
					ImageApp_MovieMulti_SetParam(_CFG_REC_ID_1, MOVIEMULTI_PARAM_FILE_TRIGEMR, 1);
				} else {
					UINT32 i, mask, movie_rec_mask;

 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
#else
				ImageApp_Movie_SetParam(_CFG_REC_ID_1, MOVIE_PARAM_FILE_TRIGEMR, 1);
#endif
				Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
				return NVTEVT_CONSUME;
			} else if (SysGetFlag(FL_MOVIE_PIM) == MOVIE_PIM_ON) {
				UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

				FlowMovie_DrawPIM(TRUE);
				{
					uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
					uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
					uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
					uiDAR = GetMovieDispAspectRatio(uiMovieSize);
				}
				if (uiDAR == MEDIAREC_DAR_16_9) {
					uiJpegWidth = (uiJpegHeight * 16) / 9;
				}

				Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
			}
			break;
		}
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	// Similar to Shutter2 key
	uiKeyAct = paramArray[0];
	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS: {
			/*
			if (gMovData.State==MOV_ST_VIEW)
			{
			    gMovData.State=MOV_ST_REC;

			}
			else if (gMovData.State==MOV_ST_REC)
			{
			    gMovData.State=MOV_ST_VIEW;
			    // update ui window icon
			    FlowMovie_UpdateIcons(TRUE);
			}
			*/
			UIFlowWndMovie_OnExeRecord(pCtrl, paramNum, paramArray);
		}
		break;
	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32  uiSoundMask;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			// stope timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}
			// enable shutter2 sound (shutter2 as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_ENTER;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			break;
		}
		break;
	}
	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_MENU, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if defined(_MODEL_WiFiSDV_)
	UINT32	uiKeyAct;

	uiKeyAct = paramArray[0];
	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			// stope timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}

			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			break;
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			if (UI_GetData(FL_WIFI_LINK) == WIFI_LINK_NG){
				Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
				BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
			}
			break;
		}
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_DOWN, paramNum, paramArray);
#endif
	return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32  uiEV;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			uiEV = SysGetFlag(FL_EV);
			if (uiEV == EV_N20) {
				SysSetFlag(FL_EV, EV_P20);
			} else {
				SysSetFlag(FL_EV, ++uiEV);
			}
			Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_EV, 1, SysGetFlag(FL_EV));
			FlowMovie_IconDrawEV(&UIFlowWndMovie_StatusICN_EVCtrl);
			break;
		case MOV_ST_REC:
			if (SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1) {
#if (0)//(PRJ == APC3)
				g_bSpeLockFun = TRUE;
				FlowMovie_StopRec();
				Ux_SendEvent(pCtrl, NVTEVT_CB_MOVIE_FINISH, 1, UIFlowWndMovie_Restart_Rec);
#endif
			}
			break;
		}
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM: {
				UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

				FlowMovie_DrawPIM(TRUE);
				{
					uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
					uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
					uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
					uiDAR = GetMovieDispAspectRatio(uiMovieSize);
				}
				if (uiDAR == MEDIAREC_DAR_16_9) {
					uiJpegWidth = (uiJpegHeight * 16) / 9;
				}
				Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
			}
			break;
		}
		break;
	// Enter menu
	default:
		Ux_PostEvent(NVTEVT_KEY_MENU, 1, NVTEVT_KEY_PRESS);
		break;
	}

	return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiSoundMask;

	switch (gMovData.State) {
	case MOV_ST_WARNING_MENU:
		if (paramNum > 0) {
			if (paramArray[0] == NVTRET_ENTER_MENU) {
				/* Create Menu window */
				gMovData.State = MOV_ST_MENU;
				Ux_OpenWindow(&MenuCommonItemCtrl, 0);
				return NVTEVT_CONSUME;
			}
		}
		gMovData.State = MOV_ST_VIEW;
		break;

	case MOV_ST_MENU:
		// disable shutter2 sound
		uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
		uiSoundMask &= ~FLGKEY_ENTER;
		Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

		g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
		g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
		Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
		FlowMovie_UpdateIcons(TRUE);

		// start timer again when exiting menu
		if (gUIMotionDetTimerID == NULL_TIMER) {
			gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
		}

		if (g_uiDateTimerID == NULL_TIMER) {
			g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
		}

		// Enable Motion Detect function in starting up movie mode
		if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
			g_uiRecordIngMotionDet = TRUE;
		} else {
			g_uiRecordIngMotionDet = FALSE;
		}

		gMovData.State = MOV_ST_VIEW;
		break;
	case MOV_ST_VIEW:
		if (paramNum > 0) {

			if ((paramNum == 2) && (paramArray[0] == NVTRET_WAITMOMENT)) {
				if (paramArray[1] == NVTRET_RESTART_REC) {
#if defined(_KEY_METHOD_4KEY_)
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
					Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
            	} else {
					FlowMovie_UpdateIcons(TRUE);
				}
			}
		}
		break;
	}

	//#NT#2018/08/10#KCHong -begin
	//#NT#Fixed Jira NA51000-1230
#if (MOVIE_MAPPING_MULTIREC == ENABLE)
	if (gMovData.State == MOV_ST_VIEW || gMovData.State == MOV_ST_REC) {
		FlowMovie_UpdateIcons(TRUE);
		if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1) ||
			ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2) ||
			ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_3) ||
			ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_4)) {
			gMovData.State = MOV_ST_REC;
		} else {
			gMovData.State = MOV_ST_VIEW;
		}
	}
#endif
	//#NT#2018/08/10#KCHong -end

#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
#endif
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeRecord(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

	// Don't stop movie recording
	switch (gMovData.State) {
	case MOV_ST_VIEW:
	case MOV_ST_VIEW|MOV_ST_ZOOM:
		// mask key while changing primary mode
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		// changing primary mode
		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_FORCETO_PLAYBACK_MODE, 0);
		break;
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	static volatile BOOL bBatteryOn = FALSE;

	UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl, STATE_CURITEM, GetBatteryLevel());
	if (KeyScan_IsACIn()) {
		bBatteryOn = !bBatteryOn;
		UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl, bBatteryOn);
	} else {
		UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl, TRUE);
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// Don't stop movie recording
	switch (gMovData.State) {
	case MOV_ST_VIEW:
	case MOV_ST_VIEW|MOV_ST_ZOOM:
		// mask key while changing primary mode
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		// changing primary mode
		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_EXE_CHANGEDSCMODE, 1, DSCMODE_CHGTO_NEXT);
		break;

	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiFolderId = 0, uiFileId = 0;
	BOOL    CheckStorageErr;
	//UINT32  gUIAviRecMaxTime;

	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:

		//#NT#2016/09/20#Bob Huang -begin
		//#NT#Support HDMI Display with 3DNR Out
		//call stop rec first before starting to rec, keep rec mode
#if (_3DNROUT_FUNC == ENABLE)
		if (!gb3DNROut)
#endif
//#NT#2016/09/20#Bob Huang -end
		{
			gMovData.State = MOV_ST_VIEW;
		}

		//#NT#2012/10/23#Philex Lin - begin
		// enable auto power off/USB detect timer
		KeyScan_EnableMisc(TRUE);
		//#NT#2012/10/23#Philex Lin - end
		FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
		UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);

		//if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
		if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF) {
			CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
		} else {
			CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
		}
		if (CheckStorageErr == FALSE) {
			DCF_GetNextID(&uiFolderId, &uiFileId);
			SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
			SysSetFlag(FL_DCF_FILE_ID, uiFileId);

			//#NT#2016/03/07#KCHong -begin
			//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
			if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
#endif
//#NT#2016/03/07#KCHong -end
				FlowMovie_UpdateIcons(TRUE);
			Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
		}
		break;

	//The flow here may be only for APC3 stop record than lock file function.
	//To be careful that gMovData have changed in UIFlowMovie_Stop.
	case MOV_ST_VIEW:
		// Enable key if user pressed shutter2 key to stop recording.
		Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:
		if (paramNum) {
			if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
			}
			FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
			FlowMovie_SetRecCurrTime(paramArray[0]);
			FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
		}
		if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl)) {
			FlowMovie_DrawPIM(FALSE);
		}

		break;
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnLoopRecFull(pCtrl, paramNum, paramArray);
}

INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if ((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM))) {
		FlowMovie_StopRec();
		if (System_GetState(SYS_STATE_CARD)  == CARD_LOCKED) {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		} else {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		}
	} else {
		Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// trigger re-start encoding
#if 0
	return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
//#NT#2015/11/24#KS Hung -begin
//#NT#SMediaRec and FileSys have new method for slow card
//Movie_SetSDSlow(TRUE);
#if _TODO
	MovRec_EnableOverlap(FALSE);
#endif
//#NT#2015/11/24#KS Hung -end
#if defined(_KEY_METHOD_4KEY_)
	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
	Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
	return NVTEVT_CONSUME;
#endif
}

INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_StopRec();
	KeyScan_EnableMisc(TRUE);
	//gMovData.State = MOV_ST_VIEW;
	gMovData.State = MOV_ST_WARNING_MENU;
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL, FLOWWRNMSG_TIMER_2SEC);
	FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnEMRCompleted(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (__DBGLVL__ >= 6)
	UINT32  uiPathId = 0;

	if (paramNum)
	{
		uiPathId = paramArray[0];
	}

	DBG_IND("EMR(%d) completed!\r\n", uiPathId);
#endif
	if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_EMR_FILE_COMPLETED))
	{
		DBG_IND("EMR(%d) completed!\r\n", uiPathId);
	}
	else if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_CARSH_FILE_COMPLETED))
	{
		DBG_IND("Crash (%d) completed!\r\n", uiPathId);
	}

	return NVTEVT_CONSUME;
}

#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	ide_enable_video(IDE_VIDEOID_1);
	switch (gMovData.State) {
	case MOV_ST_VIEW:
		FlowMovie_UpdateIcons(TRUE);
		break;
	}
	return NVTEVT_CONSUME;
}
#endif

INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
		// check if enter engineer mode
		if (EngineerMode_CheckEng())
		{
			cal_system_init();
			//#NT#2016/06/23#Niven Cho -begin
			//#NT#Enter calibration by cgi event or command event
			Ux_PostEvent(NVTEVT_KEY_CALIBRATION, 0);
			//#NT#2016/06/23#Niven Cho -end
		}
#endif
//#NT#2016/03/02#Niven Cho -begin
//#NT#Fix FAST_BOOT + LINUX + without card, boot failed.
#if defined(_CPU2_LINUX_)
	if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
	}
#endif
//#NT#2016/03/02#Niven Cho -end
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_IconDrawDZoom(&UIFlowWndMovie_Zoom_StaticCtrl);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiEvent;
	if (paramNum > 0) {
		uiEvent = paramArray[0];
		if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE) {
			return NVTEVT_CONSUME;
		}
	} else {
		return NVTEVT_CONSUME;
	}
	switch (gMovData.State) {
	case MOV_ST_VIEW:
		//#NT#2016/03/07#KCHong -begin
		//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
#endif
//#NT#2016/03/07#KCHong -end
			FlowMovie_UpdateIcons(TRUE);
		break;
	}

	g_PreviewStable = TRUE;
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_UpdateIcons(TRUE);

	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);

#if (SDHOTPLUG_FUNCTION == ENABLE)
	Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif

	return NVTEVT_CONSUME;
}

#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{
	RMCINFO RMCInfo;

	GPSRec_GetRMCDate(&RMCInfo);
#if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
	mp4log_AddLog(0, (char *)&RMCInfo, sizeof(RMCINFO));
#else   // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
	memcpy(&(gpsdata.rmcinfo), &RMCInfo, sizeof(RMCINFO));
#endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)

#if 0
	debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n", gpsdata.rmcinfo.Latitude, gpsdata.rmcinfo.NSInd, gpsdata.rmcinfo.Longitude, gpsdata.rmcinfo.EWInd);
#endif
}
#endif

static void UIFlowWndMovie_OnMotionDetect(void)
{
	static UINT32  uiMotionDetGo = 0;
	static UINT32  uiMotionDetStop = 0;

	//#NT#2016/11/01#Adam Su -begin
	//#NT#fix mantis issue 0106933
	static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
	//#NT#2016/11/01#Adam Su -end

	//#NT#2016/10/18#Jeah Yen -begin
	//#NT#move code to support sensor map
	static UINT32  uiMotionDetRet = 0;
	Ux_SendEvent(0, NVTEVT_EXE_MOTION_DET_RUN, 1, (UINT32)&uiMotionDetRet);
	if (uiMotionDetRet == TRUE)
		//#NT#2016/10/18#Jeah Yen -end
	{
		uiMotionDetGo++;
		DBGD(uiMotionDetGo);
		if (uiMotionDetGo >= 2) {
			uiMotionDetStop = 0;
			// Recording of modtion detection in pure CarDV path
			if (!((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)))) {
				// reset uiMotionDetGo
				uiMotionDetGo = 0;
				//#NT#2016/11/01#Adam Su -begin
				//#NT#fix mantis issue 0106933
				bMotionDetRec = TRUE;
				//#NT#2016/11/01#Adam Su -end
				// press key to record video
#if defined(_KEY_METHOD_4KEY_)
				Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
				Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
			}
		}
	} else {
//#NT#2016/11/01#Adam Su -begin
//#NT#fix mantis issue 0106933
		if (bMotionDetRec == TRUE) {
			uiMotionDetStop++;
			DBGD(uiMotionDetStop);
			if (uiMotionDetStop >= 2) { // 1 sec
				uiMotionDetGo = 0;
			}
			if (uiMotionDetStop >= 20) { // 10 Sec
				uiMotionDetStop = 0;
				if (FlowMovie_GetRecCurrTime() >= 1) {
// CardDV path
					if (gMovData.State == MOV_ST_REC || gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)) {
						FlowMovie_StopRec();
						// update ui window icon
						FlowMovie_UpdateIcons(TRUE);
						bMotionDetRec = FALSE;
					}
				}
			}
		}
//#NT#2016/11/01#Adam Su -end
	}
}

INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	//#NT#2016/03/07#KCHong -begin
	//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
	UINT32 TLRet = 0;
	static UINT32 Cnt = 0;
#endif
//#NT#2016/03/07#KCHong -end

#if (GPS_FUNCTION == ENABLE)
	static UINT32 GPSHeartBeatPrev = 0, GPSHeartBeatNow = 0;
#endif
	UINT32  uiEvent;
	uiEvent = paramNum ? paramArray[0] : 0;
	switch (uiEvent) {
    	case NVTEVT_01SEC_TIMER:
        	if(g_uiRecStopTimerCnt){
        	    g_uiRecStopTimerCnt--;
        	    if(g_uiRecStopTimerCnt==0){
        	        if (g_UIStopRecTimerID != NULL_TIMER) {
                		GxTimer_StopTimer(&g_UIStopRecTimerID);
        	        }
        	        Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
        	        break;
        	    }
        	}
    	    break;
	case NVTEVT_05SEC_TIMER:
//#NT#2016/03/07#KCHong -begin
//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		TLRet = MovieTLLPR_Process(TIMELAPSE_FROM_TIMER);
		if ((TLRet & TL_FLOW_MASK) == TL_FLOW_LPR) {
			if ((TLRet & TL_STATE_MASK) == TL_STATE_RECORD) {
// flash REC icon one time to indicate capturing
				if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
					Cnt ++;
				}

				if (Cnt == 2) {
					Cnt = 0;
					UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
				}
				FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
				FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
				FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
			}
		}
#endif
//#NT#2016/03/07#KCHong -end

#if(AUTO_WIFI==ENABLE)
		{
			static BOOL autoWifi = FALSE;

			if (!autoWifi) {
				//#NT#2016/03/23#Isiah Chang -begin
				//#NT#add new Wi-Fi UI flow.
#if(WIFI_UI_FLOW_VER == WIFI_UI_VER_1_0)
				Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
#endif
//#NT#2016/03/23#Isiah Chang -end
				BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
				autoWifi = TRUE;
			}
		}
#endif

		//get GPS/GSensor Data
		//#NT#2013/3/20#Philex Lin-begin
#if (GPS_FUNCTION == ENABLE)
#if (LOG_DBGINFO_IN_GPS_SECTION == DISABLE)
		UIFlowWndMovie_UpdateSpeedData();
#endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == DISABLE)
		g_GPSStatus = GPSRec_GetSpeed(&g_CurSpeed);
#endif  // #if (GPS_FUNCTION == ENABLE)
//#NT#2013/3/20#Philex Lin-end

		// Do Motion detect process
		if (g_uiRecordIngMotionDet == TRUE) {
			UIFlowWndMovie_OnMotionDetect();
		}
		break;

	case NVTEVT_1SEC_TIMER:
		//#NT#2015/10/02#KCHong -begin
		//#NT#For GPS & ADAS
#if (GPS_FUNCTION == ENABLE)
		GPSHeartBeatNow = GetGPSHeartBeat();
		g_GPSLinked = (GPSHeartBeatNow != GPSHeartBeatPrev) ? TRUE : FALSE;
		GPSHeartBeatPrev = GPSHeartBeatNow;
#endif
//#NT#2015/10/02#KCHong -end

#if (_ADAS_FUNC_ == ENABLE)
		if (UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			g_uiAdasAlertSecCnt++;
			if (g_uiAdasAlertSecCnt == 2) {
				UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
				UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
				g_uiAdasAlertSecCnt = 0;
			} else {
				return NVTEVT_CONSUME;
			}
		}
#endif  // #if (_ADAS_FUNC_ == ENABLE)

		if (g_bDelayUpdateIcon) {
			FlowMovie_UpdateIcons(TRUE);
			g_bDelayUpdateIcon = FALSE;
		}

		FlowMovie_OnTimer1SecIndex();
		// Isiah, implement YUV merge mode of recording func.
#if _TODO
		if (MovRec_IsRecording()) {
			Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_STEP, 0);
		}
#endif

#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
		if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
			if (!MovRec_IsRecording()) {
				if (g_PreviewStable_Record == FALSE) {
					if ((g_ACPlug == TRUE) && (g_PreviewStable == TRUE)) {
//if (g_PreviewStable == TRUE)
						g_PreviewStable_Record = TRUE;
#if defined(_KEY_METHOD_4KEY_)
						Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
						Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
					}
				}
			}
		}
#endif
		break;
	}
	Ux_DefaultEvent(pCtrl, NVTEVT_TIMER, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
	g_ACPlug = TRUE;
// start record if receiving preview stable event
	if ((g_PreviewStable == TRUE) && (g_PreviewStable_Record == FALSE)) {
		g_PreviewStable_Record = TRUE;
		if (UI_GetData(FL_WIFI_AUTO_RECORDING) == WIFI_AUTO_RECORDING_ON) {
//Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
		}
	}
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	g_ACPlug = FALSE;
	//Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if 0
	UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

	if (SysGetFlag(FL_GSENSOR) != GSENSOR_OFF) {
		if ((gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT)) {
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) {

#if (MOVIE_MULTI_RECORD_FUNC)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_DUAL
					|| GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_CLONE) {
					DBG_DUMP("dual record, only support set crash\r\n");
					MovRec_SetCrash();
					return NVTEVT_CONSUME;
				}
#endif
				if (uiWidth <= 1920) {
					DBG_DUMP("process flash video record!!!\r\n");
					MovRec_StopFlash(0);
				} else {
					DBG_DUMP("Set Crash!!!\r\n");
					MovRec_SetCrash();
				}
			}
		}
	}
#else
	if (SysGetFlag(FL_GSENSOR) != GSENSOR_OFF) {
		if ((gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT)) {
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) {
#if (MOVIE_MAPPING_MULTIREC == ENABLE)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
					ImageApp_MovieMulti_SetParam(_CFG_REC_ID_1, MOVIEMULTI_PARAM_FILE_TRIGEMR, 1);
				} else {
					UINT32 i, mask, movie_rec_mask;

 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
#else
				ImageApp_Movie_SetParam(_CFG_REC_ID_1, MOVIE_PARAM_FILE_TRIGEMR, 1);
#endif
			}
		}
	}
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_ADAS_FUNC_ == ENABLE)
	UINT32 AlarmType;
	ADAS_APPS_RESULT_INFO *pAdasRlt = alg_MovieExe_GetAdasRltOSD();

	Ux_FlushEventByRange(NVTEVT_CB_ADAS_SHOWALARM, NVTEVT_CB_ADAS_SHOWALARM);
	AlarmType = paramArray[0];

	switch (AlarmType) {
	case ADAS_ALARM_LD:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_LDWS_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, FALSE);
			switch (pAdasRlt->LdwsRsltInfo.DepartureDirSound) {
			case LDWS_DEPARTURE_LEFT:
				UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
				break;
			case LDWS_DEPARTURE_RIGHT:
				UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_RIGHT_ALERT);
				break;
			default:
				break;
			}
		}
		break;

	case ADAS_ALARM_FC:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_FCS_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, FALSE);

			if ((pAdasRlt->FcwsRsltInfo.uiKelDist < 15) && (pAdasRlt->FcwsRsltInfo.uiKelDist > 0)) {
				UxState_SetData(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_FCWS_Alert_ICON_FCW_FAR_ALERT);
			}
		}
		break;

	case ADAS_ALARM_GO:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, TRUE);
			UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
		}
		break;

	case ADAS_ALARM_STOP:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, TRUE);
			UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
		}
		break;

	default:
		break;
	}
#endif  // #if (_ADAS_FUNC_ == ENABLE)
	return NVTEVT_CONSUME;
}

//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_DDD_FUNC_ == ENABLE)
	UINT32 AlarmType;
	AlarmType = paramArray[0];
#if 0//Add for test
	GxSound_SetOutDevConfigIdx(0);
#endif
	switch (AlarmType) {
	case DDD_ALARM_PERCLOS:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_YAWN:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_DIS:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING2_TONE);
		break;

	case DDD_ALARM_NODE:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_EYE:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING1_TONE);
		break;

	default:
		break;
	}
#endif
	return NVTEVT_CONSUME;
}
//#NT#2016/07/20#Brain Yen -end

//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
	{
		Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
		EngineerMode_Open();
	}
#endif
	return NVTEVT_CONSUME;

}
//#NT#2016/06/23#Niven Cho -end
INT32 UIFlowWndMovie_OnOverTime(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if defined(_KEY_METHOD_4KEY_)
	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
	Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBackgroundDone(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	NVTEVT event=paramArray[ONDONE_PARAM_INDEX_CMD];
	//UINT32 status= paramArray[ONDONE_PARAM_INDEX_RET];

	debug_ind(("UIFlowWndMovie_OnBackgroundDone event = 0x%x\r\n", event));

	switch (event) {
	case NVTEVT_BKW_STOPREC_PROCESS: {
		    g_uiRecStopTimerCnt=0;
		    FlowMovie_UpdateIcons(TRUE);

		}
		break;
	default:
		break;
	}

	return NVTEVT_CONSUME;

}
//---------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_WIFI)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_DrawingLine)
///#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
CTRL_LIST_ITEM(UIFlowWndMovie_ALG_Draw)
//#NT#2016/06/08#Lincy Lin -end
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
EVENT_END

//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_Status_WIFICtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_WIFI)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function

//---------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
EVENT_END

//---------------------UIFlowWndMovie_ALG_DrawCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ALG_Draw)
CTRL_LIST_END
//----------------------UIFlowWndMovie_ALG_DrawCtrl Event---------------------------
INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_ALG_Draw)
EVENT_ITEM(NVTEVT_REDRAW, UIFlowWndMovie_ALG_Draw_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_ALG_Draw_OSD(pCtrl, paramNum, paramArray);
}

//---------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_LDWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_FCWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_SNG_Alert)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_LDWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_LDWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_FCWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_FCWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_SNG_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_SNG_Alert)
EVENT_END

