//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndPhotoRes.c"
#include "UIFlowPhotoParams.h"
#include "UIDisplay.h"
#include "UIFlow.h"
#include "ImageApp_Photo.h"
#include "fd_lib.h"
#include "display.h"
#include "timer.h"
#if (CALIBRATION_FUNC == ENABLE)
#include "EngineerMode.h"
#endif

#define FD_FRAME_RATE               3//10   //(10frame/30fps) = 333ms = update time

#define THIS_DBGLVL         2 // 0=FATAL, 1=ERR, 2=WRN, 3=UNIT, 4=FUNC, 5=IND, 6=MSG, 7=VALUE, 8=USER
///////////////////////////////////////////////////////////////////////////////
#define __MODULE__          UIFlowWndPhoto
#define __DBGLVL__          ((THIS_DBGLVL>=PRJ_DBG_LVL)?THIS_DBGLVL:PRJ_DBG_LVL)
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
//#define __DBGFLT__          "[cap]"
//#define __DBGFLT__          "[fd]"
//#define __DBGFLT__          "[io]"
#include "DebugModule.h"
//---------------------FlowPhotoCtrl Global Variables----------


//-----------------------------------------------------------------------------
// UIFlowWndPhoto User Definitions
//-----------------------------------------------------------------------------
// Photo mode key mask
#define PHOTO_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define PHOTO_KEY_RELEASE_MASK      (FLGKEY_KEY_MASK_DEFAULT)
#define PHOTO_KEY_CONTINUE_MASK     FLGKEY_KEY_CONT_MASK_DEFAULT

static UINT32 g_uiMaskKeyPress      = PHOTO_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = PHOTO_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = PHOTO_KEY_CONTINUE_MASK;

static UINT32 g_uiSelfTimerID       = NULL_TIMER;
static UINT32 g_uiQviewTimerID      = NULL_TIMER;
static volatile BOOL g_bRedLEDOn    = FALSE;
//static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *pAlgInfo);


typedef struct _UIFlowInfoTypePhoto {
	BOOL                       bIsPreview;
} UIFlowInfoTypePhoto;


UIFlowInfoTypePhoto UIFlowInfoPhotoInitVal = {
	TRUE,                           //bIsPreview;
};

static UIFlowInfoTypePhoto  UIFlowInfoPhoto;
static UIFlowInfoTypePhoto *localInfo = &UIFlowInfoPhoto;


//---------------------UIFlowWndPhotoCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Selftimer)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_FreePic)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ISO)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_AntiShaking)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_FD)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_DZoom)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ContinueShot)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_HDR)
CTRL_LIST_END

//----------------------UIFlowWndPhotoCtrl Event---------------------------
INT32 UIFlowWndPhoto_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnUpdateInfo(VControl *, UINT32, UINT32 *);
#if 0
INT32 UIFlowWndPhoto_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *, UINT32, UINT32 *);
#endif
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnKeyMode(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFocusEnd(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnFdEnd(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndPhoto_OnSdEnd(VControl *, UINT32, UINT32 *);
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndPhoto_OnKeyCalibration(VControl *, UINT32, UINT32 *);
//#NT#2016/06/23#Niven Cho -end
EVENT_BEGIN(UIFlowWndPhoto)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, UIFlowWndPhoto_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, UIFlowWndPhoto_OnClose)
EVENT_ITEM(NVTEVT_UPDATE_INFO, UIFlowWndPhoto_OnUpdateInfo)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndPhoto_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_MENU, UIFlowWndPhoto_OnKeyMenu)
#if defined(_KEY_METHOD_4KEY_)
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndPhoto_OnKeyNext)    // OK Key
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndPhoto_OnKeySelect)   // REC key
EVENT_ITEM(NVTEVT_KEY_PREV,       UIFlowWndPhoto_OnKeyZoomout)    // Up Key
EVENT_ITEM(NVTEVT_KEY_NEXT,     UIFlowWndPhoto_OnKeyZoomin)   //Down key
#else
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndPhoto_OnKeyNext)       // Right Key
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndPhoto_OnKeySelect)   // Enter key
#endif
EVENT_ITEM(NVTEVT_CHILD_CLOSE, UIFlowWndPhoto_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_INIT, UIFlowWndPhoto_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, UIFlowWndPhoto_OnStorageChange)
EVENT_ITEM(NVTEVT_BATTERY, UIFlowWndPhoto_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW, UIFlowWndPhoto_OnBatteryLow)
EVENT_ITEM(NVTEVT_TIMER, UIFlowWndPhoto_OnTimer)
EVENT_ITEM(NVTEVT_CB_ZOOM, UIFlowWndPhoto_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_ALGMSG_FOCUSEND, UIFlowWndPhoto_OnFocusEnd)
//EVENT_ITEM(NVTEVT_CB_FDEND,UIFlowWndPhoto_OnFdEnd)
//EVENT_ITEM(NVTEVT_CB_SDEND,UIFlowWndPhoto_OnSdEnd)
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
EVENT_ITEM(NVTEVT_KEY_CALIBRATION, UIFlowWndPhoto_OnKeyCalibration)
//#NT#2016/06/23#Niven Cho -end
EVENT_END

static void UIFlowWndPhoto_OnQVStart(void);
static void UIFlowWndPhoto_OnFdEnd(void);
//static void UIFlowWndPhoto_OnSdEnd(void);




static void FlowPhoto_InitStartupFuncs(void)
{
	UINT32 StartFunc = 0;

	StartFunc |= UIAPP_PHOTO_AE;
	StartFunc |= UIAPP_PHOTO_AWB;

	Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_START_FUNC, 2, StartFunc, UIAPP_PHOTO_NOWAITIDLE);
}

static void FlowPhoto_SetPreview(void)
{
	DBG_IND("\r\n");

	/* reset state to PHOTO_ST_VIEW */
	gPhotoData.State = PHOTO_ST_VIEW;
	localInfo->bIsPreview = TRUE;
	//#NT#2010/08/20#Lincy Lin -begin
	//#NT#Fine Tune Shot to Shot
#if 0
	localInfo->bIsForceExitQuickView = FALSE;
#endif
	//#NT#2010/08/20#Lincy Lin -end
	// unlock AE/AWB
	FlowPhoto_InitStartupFuncs();



	/* Set to preview mode */
	UI_Show(UI_SHOW_PREVIEW, TRUE);
	//SwTimer_DelayMs(5000);
	//CHKPNT;

	/* close quick view image */
	UI_Show(UI_SHOW_QUICKVIEW, FALSE);

#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
#endif
	//SwTimer_DelayMs(5000);
	//CHKPNT;

	/* Resume key after quick view completed */
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

	/* Set FD/SD functions againg after exiting Menu */
	FlowPhoto_SetFdSdProc(TRUE);

	/* Update window info */
	FlowPhoto_UpdateIcons(TRUE);

	exam_msg("{BackPreivew}\r\n");

}

static void UIFlowWndPhoto_BackPreviewHandle(void)
{
	BOOL isToPreview = FALSE;

	DBG_IND("\r\n");


	if ((gPhotoData.QuickViewCount == 0) && (!pPhotoExeInfo->isStartCapture)) {
		isToPreview = TRUE;
	}
	//#NT#2010/08/20#Lincy Lin -begin
	//#NT#Fine Tune Shot to Shot
#if 0
	else if (localInfo->bIsForceExitQuickView && (!pPhotoExeInfo->isStartCapture)) {
		isToPreview = TRUE;
		if (localInfo->isQviewTimerStart) {
			GxTimer_StopTimer(&localInfo->uiQviewTimerID);
			localInfo->isQviewTimerStart = FALSE;
		}
	}
#endif
	//#NT#2010/08/20#Lincy Lin -end
	if ((!localInfo->bIsPreview) && isToPreview) {
		FlowPhoto_SetPreview();
	}
}
#if _FD_FUNC_
static void FlowPhoto_ClrFDRect(void)
{
	UINT32 i;
	DISPLAYER_PARAM   DispLyr = {0} ;
	PDISP_OBJ         pDispObj = NULL;

	pDispObj = disp_getDisplayObject(DISP_1);
	for (i = 0; i < 16; i++) {
		DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0 << i;
		DispLyr.SEL.SET_FDEN.bEn = FALSE;
		pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
	}
	pDispObj->load(TRUE);
}
#endif

static INT32 UIFlowWndPhoto_OnExeCapture(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiEvtKeyAct = 0;

	if (paramNum > 0) {
		uiEvtKeyAct = paramArray[0];
	}

	switch (uiEvtKeyAct) {
	case NVTEVT_KEY_PRESS: {
			switch (gPhotoData.State) {
			case PHOTO_ST_VIEW:
				/* Check if in quick review process */
				if (SysGetFlag(FL_QUICK_REVIEW) != QUICK_REVIEW_0SEC) {
					if (g_uiQviewTimerID != NULL_TIMER) {
						GxTimer_StopTimer(&g_uiQviewTimerID);
						//g_bQviewTimerStart = FALSE;

						// unlock AE/AWB
						FlowPhoto_InitStartupFuncs();

						/* Set to preview mode */
						UI_Show(UI_SHOW_PREVIEW, TRUE);

						/* close quick view image */
						UI_Show(UI_SHOW_QUICKVIEW, FALSE);

						#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
						/* open VDO2 background */
						UI_Show(UI_SHOW_BACKGND, TRUE);
						#endif

						/* Resume key after quick view completed */
						Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
						Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

						/* Update window info */
						FlowPhoto_UpdateIcons(TRUE);
						return NVTEVT_CONSUME;
					}
				}

				/* Check capture prerequisite */
				if (FlowPhoto_IsStorageErr() == TRUE) {
					debug_err(("UIFlowWndPhoto_OnKeyShutter2: Card or memory full!\r\n"));
					gPhotoData.State = PHOTO_ST_WARNING_MENU;
					return NVTEVT_CONSUME;
				}
				if (GetBatteryLevel() == BATTERY_EXHAUSTED) {
					debug_err(("UIFlowWndPhoto_OnKeyShutter2: Battery is too low!\r\n"));
					return NVTEVT_CONSUME;
				}
				#if 0
				if (UI_GetData(FL_SHDR) == SHDR_ON) {
					DBG_WRN("HDR not support Capture\r\n");
					return NVTEVT_CONSUME;
				}
				#endif

				// check free pic number
				if (SysGetFlag(FL_CONTINUE_SHOT) != CONTINUE_SHOT_OFF) {
					if (FlowPhoto_GetFreePicNum() < 2) {
						UINT32 uiMsg = 0;

						uiMsg = (System_GetState(SYS_STATE_CARD)  == CARD_REMOVED) ? UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD : UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL;
						gPhotoData.State = PHOTO_ST_WARNING_MENU;
						Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, uiMsg, FLOWWRNMSG_TIMER_2SEC);
						return NVTEVT_CONSUME;
					}
				}

				switch (SysGetFlag(FL_SELFTIMER)) {        // set capture mode by system flag
				case SELFTIMER_2SEC:
					/* Suspend all keys, except S2 key while selftimer started */
					Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
					FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl, 2);
					gPhotoData.SelfTimerCount = 20;              // set time counter
					gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
					//KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
					UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
					if (g_uiSelfTimerID == NULL_TIMER) {
						g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
					}
					break;
				case SELFTIMER_5SEC:
					/* Suspend all keys, except S2 key while selftimer started */
					Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
					FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl, 5);
					gPhotoData.SelfTimerCount = 50;         // set time counter
					gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
					//KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
					UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
					if (g_uiSelfTimerID == NULL_TIMER) {
						g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
					}
					break;
				case SELFTIMER_10SEC:
					/* Suspend all keys, except S2 key while selftimer started */
					Input_SetKeyMask(KEY_PRESS, FLGKEY_ENTER);
					FlowPhoto_IconDrawSelftimerTime(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl, 10);
					gPhotoData.SelfTimerCount = 100;        // set time counter
					gPhotoData.State = PHOTO_ST_SELFTIMER;  // set working state to self-timer state
					//#NT#2012/8/1#Philex - begin
					//KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, TRUE);
					UISound_Play(DEMOSOUND_SOUND_KEY_TONE);
					//#NT#2012/8/1#Philex - begin
					if (g_uiSelfTimerID == NULL_TIMER) {
						g_uiSelfTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
					}
					break;
				default:
					/* Suspend all keys before sending capture command */
					Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
					Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

					//#NT#2016/04/28#Lincy Lin -begin
					//#NT#Fix sidebyside capture quickview will have preview image on background
					UI_Show(UI_SHOW_PREVIEW, FALSE);
					//#NT#2016/04/28#Lincy Lin -end

					/* Clear the whole OSD screen */
					UxCtrl_SetAllChildShow(pCtrl, FALSE);

					gPhotoData.State = PHOTO_ST_CAPTURE;    // enter capture state
					FlowPhoto_DoCapture();                  // do capture directly
					break;
				}
				break;
			case PHOTO_ST_SELFTIMER:
				gPhotoData.State = PHOTO_ST_VIEW;
				gPhotoData.SelfTimerCount = 0;
				//KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
				FlowPhoto_IconHideSelftimer(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl);
				// resume press mask to default
				Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
				break;
			}
			break;
		}

	case NVTEVT_KEY_RELEASE: {
			// need to stop infinite burst shot
			if (UI_GetData(FL_CONTINUE_SHOT) == CONTINUE_SHOT_BURST) {
				Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_CAPTURE_STOP, 0);
			}
			break;
		}

	default:
		debug_err(("UIFlowWndPhoto_OnKeyShutter2: Unknown evt 0x%x\r\n", uiEvtKeyAct));
		break;
	}
	return NVTEVT_CONSUME;
}

#if 1
static INT32 UIFlowWndPhoto_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiEvtKeyAct = 0;

	if (paramNum > 0) {
		uiEvtKeyAct = paramArray[0];
	}

	switch (uiEvtKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		if (DZOOM_IDX_GET() > DZOOM_IDX_MAX()) {
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gPhotoData.State &= ~PHOTO_ST_ZOOM;
			return NVTEVT_CONSUME;
		}
		switch (gPhotoData.State) {
		case PHOTO_ST_VIEW:
		case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);
			/*
			 * Suspend all keys while keep ZoomIn pressed.
			 * Gotta resume them after ZoomIn key released.
			 */
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
			FlowPhoto_ForceLockFdSd();
			gPhotoData.State |= PHOTO_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
		gPhotoData.State &= ~PHOTO_ST_ZOOM;
		FlowPhoto_SetFdSdProc(FlowPhoto_GetSDStatus());
		/* Resume keys after ZoomIn released */
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
		break;

	default:
		debug_err(("UIFlowWndPhoto_OnKeyZoomin: Unknown evt 0x%x\r\n", uiEvtKeyAct));
		break;
	}

	return NVTEVT_CONSUME;
}

static INT32 UIFlowWndPhoto_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiEvtKeyAct = 0;

	if (paramNum > 0) {
		uiEvtKeyAct = paramArray[0];
	}

	switch (uiEvtKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:

		switch (gPhotoData.State) {
		case PHOTO_ST_VIEW:
		case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);
			/*
			 * Suspend all keys while keep ZoomIn pressed.
			 * Gotta resume them after ZoomIn key released.
			 */
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
			FlowPhoto_ForceLockFdSd();
			gPhotoData.State |= PHOTO_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
		gPhotoData.State &= ~PHOTO_ST_ZOOM;
		FlowPhoto_SetFdSdProc(FlowPhoto_GetSDStatus());
		/* Resume keys after ZoomIn released */
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
		break;

	default:
		debug_err(("UIFlowWndPhoto_OnKeyZoomOut: Unknown evt 0x%x\r\n", uiEvtKeyAct));
		break;
	}

	return NVTEVT_CONSUME;
}
#endif


INT32 UIFlowWndPhoto_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	//#NT#2016/10/04#Lincy Lin -begin
	//#NT#Support SD hot plug function
#if (SDHOTPLUG_FUNCTION == ENABLE)
	if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
		return NVTEVT_CONSUME;
	}
#endif
	//#NT#2016/10/04#Lincy Lin -end
	UIFlowInfoPhoto = UIFlowInfoPhotoInitVal;
	FlowPhoto_InitCfgSetting();
	FlowPhoto_InitStartupFuncs();

	/* Init window key mask variables & set key press/release/continue mask */
	gPhotoData.State = PHOTO_ST_VIEW;
	g_uiMaskKeyPress = PHOTO_KEY_PRESS_MASK;
	g_uiMaskKeyRelease = PHOTO_KEY_RELEASE_MASK;
	g_uiMaskKeyContinue = PHOTO_KEY_CONTINUE_MASK;
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
	Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyContinue);

	gPhotoData.SysTimeCount = 0;
	/* Update window info */
	FlowPhoto_UpdateIcons(TRUE);
	/* set FD/SD feature */
	FlowPhoto_SetFdSdProc(TRUE);

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if _FD_FUNC_
	FlowPhoto_ClrFDRect();
#endif
	// stop SelTimerID/QViewTimerID
	if (g_uiSelfTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_uiSelfTimerID);
	}

	if (g_uiQviewTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_uiQviewTimerID);
	}

	/* Once close photo window, reset selftimer to off state */
//    SysSetFlag(FL_SELFTIMER, SELFTIMER_OFF);

	g_bRedLEDOn = FALSE;
	//KeyScan_TurnOffLED(KEYSCAN_LED_RED);

	gPhotoData.QuickViewCount = 0;
	gPhotoData.SelfTimerCount = 0;

	FlowPhoto_InitStartupFuncs();

	//#NT#2016/10/04#Lincy Lin -begin
	//#NT#Support SD hot plug function
	/* Set to preview mode */
	UI_Show(UI_SHOW_PREVIEW, TRUE);

	/* close quick view image */
	UI_Show(UI_SHOW_QUICKVIEW, FALSE);
	//#NT#2016/10/04#Lincy Lin -end

	#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
	#endif

	/* Reset key press/release/continue mask to default */
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnUpdateInfo(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (paramNum != 1) {
		DBG_ERR("paramNum = %d\r\n", paramNum);
		return NVTEVT_CONSUME;
	}
	switch (paramArray[0]) {
	case UIAPPPHOTO_CB_PREVIEW_STABLE:

		break;
	case UIAPPPHOTO_CB_CAPSTART:
		localInfo->bIsPreview = FALSE;
		break;
	case UIAPPPHOTO_CB_QVSTART:
		UIFlowWndPhoto_OnQVStart();
		break;
	case UIAPPPHOTO_CB_JPGOK:
		break;
	case UIAPPPHOTO_CB_FSTOK:
		/* Update window info */
		FlowPhoto_UpdateIcons(TRUE);
		break;
	case UIAPPPHOTO_CB_CAPTUREEND:
		// unlock AE/AWB
		//FlowPhoto_InitStartupFuncs();
		UIFlowWndPhoto_BackPreviewHandle();
		break;

	case UIAPPPHOTO_CB_FDEND:
		UIFlowWndPhoto_OnFdEnd();
		break;

	case UIAPPPHOTO_CB_SDEND:
		if (SysGetFlag(FL_FD) == FD_SMILE) {
			if ((gPhotoData.State != PHOTO_ST_CAPTURE) && (gPhotoData.QuickViewCount == 0)) {
				/* Enable FD frame show */
				UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl, TRUE);
				#if(OSD2_FUNC)
				UI_Show(UI_SHOW_INFO, FALSE); //FD layer
				#endif
				Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
			}
		}
		break;
	case UIAPPPHOTO_CB_UCTRL_UPDATE_UI:
		FlowPhoto_InitCfgSetting();
		FlowPhoto_UpdateIcons(TRUE);
		exam_msg("PhotoUpdateUI\r\n");
		break;
	}

	return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndPhoto_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32 uiEV;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gPhotoData.State) {
		case PHOTO_ST_VIEW:
		case PHOTO_ST_VIEW|PHOTO_ST_ZOOM:
			uiEV = SysGetFlag(FL_EV);
			if (uiEV == EV_N20) {
				SysSetFlag(FL_EV, EV_P20);
			} else {
				SysSetFlag(FL_EV, ++uiEV);
			}

			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_EV, 1, SysGetFlag(FL_EV));
			FlowPhoto_IconDrawEV(&UIFlowWndPhoto_StatusICN_EVCtrl);
			break;
		}
		break;
	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		if (g_bRedLEDOn == FALSE) {
			g_bRedLEDOn = TRUE;
			//KeyScan_TurnOnLED(KEYSCAN_LED_RED);
		} else {
			g_bRedLEDOn = FALSE;
			//KeyScan_TurnOffLED(KEYSCAN_LED_RED);
		}
		break;
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnKeyShutter1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnExeCapture(pCtrl, paramNum, paramArray);
}
#if 1
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
#endif
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32  uiSoundMask;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gPhotoData.State) {
		case PHOTO_ST_VIEW:
			// enable shutter2 sound (shutter2 as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_SHUTTER2;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

			/* Force to lock FD/SD functions before opening Menu */
			FlowPhoto_ForceLockFdSd();
			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gPhotoData.State = PHOTO_ST_MENU;
			break;
		}
		break;
	}
	return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndPhoto_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiKeyAct = NVTEVT_KEY_PRESS;

	if (paramNum == 1) {
		uiKeyAct = paramArray[0];
	} else {
		return NVTEVT_CONSUME;
	}

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);

		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_EXE_CHANGEDSCMODE, 1, DSCMODE_CHGTO_NEXT);
		break;
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (gPhotoData.State) {
	case PHOTO_ST_VIEW:
	case (PHOTO_ST_VIEW|PHOTO_ST_ZOOM):
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);

		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_FORCETO_PLAYBACK_MODE, 0);
		break;
	}

	return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndPhoto_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnKeyShutter2(pCtrl, paramNum, paramArray);
}

INT32 UIFlowWndPhoto_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndPhoto_OnKeyMenu(pCtrl, paramNum, paramArray);
}

INT32 UIFlowWndPhoto_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiSoundMask;

	/* Set key mask to self-original state */
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
	Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyContinue);

	switch (gPhotoData.State) {
	case PHOTO_ST_WARNING_MENU:
		if (paramNum > 0) {
			if (paramArray[0] == NVTRET_ENTER_MENU) {
				/* Force to lock FD/SD functions before opening Menu */
				FlowPhoto_ForceLockFdSd();
				/* Create Menu window */
				gPhotoData.State = PHOTO_ST_MENU;
				Ux_OpenWindow(&MenuCommonItemCtrl, 0);
				return NVTEVT_CONSUME;
			}
		}
		gPhotoData.State = PHOTO_ST_VIEW;
		break;

	case PHOTO_ST_MENU:
		// disable shutter2 sound
		uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
		uiSoundMask &= ~FLGKEY_SHUTTER2;
		Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

		gPhotoData.State = PHOTO_ST_VIEW;

		FlowPhoto_InitCfgSetting();
		// set image ratio here
		//Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_IMAGE_RATIO,1,GetPhotoSizeRatio(UI_GetData(FL_PHOTO_SIZE)));

		// unlock AE/AWB
		FlowPhoto_InitStartupFuncs();

		/* Set to preview mode */
		UI_Show(UI_SHOW_PREVIEW, TRUE);

		/* close quick view image */
		UI_Show(UI_SHOW_QUICKVIEW, FALSE);

		#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
		/* open VDO2 background */
		UI_Show(UI_SHOW_BACKGND, TRUE);
		#endif

		/* Resume key after normal capture completed */
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

		/* Set FD/SD functions againg after exiting Menu */
		FlowPhoto_SetFdSdProc(TRUE);
		/* Update window info */
		FlowPhoto_UpdateIcons(TRUE);
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
	{
		// check if enter engineer mode
		if (EngineerMode_CheckEng())
		{
			//#NT#2016/06/23#Niven Cho -begin
			//#NT#Enter calibration by cgi event or command event
			Ux_PostEvent(NVTEVT_KEY_CALIBRATION, 0);
			//#NT#2016/06/23#Niven Cho -end
		}
	}
#endif
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	//#NT#2016/10/04#Lincy Lin -begin
	//#NT#Support SD hot plug function
#if (SDHOTPLUG_FUNCTION == ENABLE)
	Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif
	//#NT#2016/10/04#Lincy Lin -end
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	static volatile BOOL bBatteryOn = FALSE;

	UxState_SetData(&UIFlowWndPhoto_StatusICN_BatteryCtrl, STATE_CURITEM, GetBatteryLevel());
	if (KeyScan_IsACIn()) {
		bBatteryOn = !bBatteryOn;
		UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl, bBatteryOn);
	} else {
		UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl, TRUE);
	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	NVTEVT event;


	if (paramNum > 0) {
		event = paramArray[0];
	} else {
		return NVTEVT_CONSUME;
	}
	switch (event) {
	case NVTEVT_01SEC_TIMER:
		if (gPhotoData.QuickViewCount != 0) {
			gPhotoData.QuickViewCount--;
			if (gPhotoData.QuickViewCount == 0) {
				if (g_uiQviewTimerID != NULL_TIMER) {
					GxTimer_StopTimer(&g_uiQviewTimerID);
				}
#if 0

				/* reset state to PHOTO_ST_VIEW */
				gPhotoData.State = PHOTO_ST_VIEW;

				/* set FD/SD feature */
				FlowPhoto_SetFdSdProc(FALSE);

				/* Set to preview mode */
				UI_Show(UI_SHOW_PREVIEW, TRUE);

				/* close quick view image */
				UI_Show(UI_SHOW_QUICKVIEW, FALSE);

				/* Update window info */
				//FlowPhoto_UpdateIcons(TRUE);

				/* Resume key after normal capture completed */
				Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
#else
				UIFlowWndPhoto_BackPreviewHandle();
#endif

				/* set DirID/FileID */
#if !USE_FILEDB
				{
					UINT32 uhFilesysDirNum, uhFilesysFileNum;

					DCF_GetNextID(&uhFilesysDirNum, &uhFilesysFileNum);
					SysSetFlag(FL_DCF_DIR_ID, uhFilesysDirNum);
					SysSetFlag(FL_DCF_FILE_ID, uhFilesysFileNum);
				}
#endif
			}
		}

		if (gPhotoData.SelfTimerCount != 0) {
			gPhotoData.SelfTimerCount--;
			if (gPhotoData.SelfTimerCount == 0) {
				if (g_uiSelfTimerID != NULL_TIMER) {
					GxTimer_StopTimer(&g_uiSelfTimerID);
				}

				// stopping LED toggle
				//KeyScan_EnableLEDToggle(KEYSCAN_LED_GREEN, FALSE);
			}
			FlowPhoto_OnTimer01SecIndex();
		}
		break;
	}
	return NVTEVT_CONSUME;
}
static void UIFlowWndPhoto_OnQVStart(void)
{
	#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, FALSE);
	#endif

	/* Set to quick review mode */
	UI_Show(UI_SHOW_QUICKVIEW, TRUE);

	FlowPhoto_UpdateIcons(FALSE);

	switch (SysGetFlag(FL_QUICK_REVIEW)) {
	case QUICK_REVIEW_2SEC:
		gPhotoData.QuickViewCount = 15;
		break;
	case QUICK_REVIEW_5SEC:
		gPhotoData.QuickViewCount = 45;
		break;
	case QUICK_REVIEW_0SEC:
		gPhotoData.QuickViewCount = 1;
		break;
	}
	if (g_uiQviewTimerID == NULL_TIMER) {
		/* Resume only S2 key while quick view timer started */
		Input_SetKeyMask(KEY_PRESS, FLGKEY_SHUTTER2);
		g_uiQviewTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
	}
}

INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

	/* Update Digital zoom icon */
	FlowPhoto_IconDrawDZoom(&UIFlowWndPhoto_StaticTXT_DZoomCtrl);

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnFocusEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
static void UIFlowWndPhoto_OnFdEnd(void)
{
	if (SysGetFlag(FL_FD) != FD_OFF) {
		if ((gPhotoData.State != PHOTO_ST_CAPTURE) && (gPhotoData.QuickViewCount == 0)) {
			/* Enable FD frame show */
			UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl, TRUE);

			/* Redraw all window OSD */
			UxCtrl_SetDirty(&UIFlowWndPhotoCtrl, TRUE);
		}
	}
}

#if 0
static void UIFlowWndPhoto_OnSdEnd(void)
{
#define    SDCount 6
	static UINT32 uiSDCount = 0;

	if (SysGetFlag(FL_SELFTIMER) == SELFTIMER_OFF) {
		if (uiSDCount++ >= SDCount) {
			uiSDCount = 0;
			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
		}
	}
}
#endif
//#NT#2016/03/25#KCHong -end
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndPhoto_OnKeyCalibration(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
	{
		Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
		EngineerMode_Open();
	}
#endif
	return NVTEVT_CONSUME;

}
//#NT#2016/06/23#Niven Cho -end
//----------------------UIFlowWndPhoto_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_SelftimerCtrl Event---------------------------
INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Selftimer)
EVENT_ITEM(NVTEVT_KEY_LEFT, UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft)
EVENT_END

INT32 UIFlowWndPhoto_StatusICN_Selftimer_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	/* Increase item index */
	Ux_SendEvent(pCtrl, NVTEVT_NEXT_ITEM, 0);
	/* Send exe to obj for handling (including set ui index) */
	Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_SELFTIMER, 1, UxState_GetData(pCtrl, STATE_CURITEM));
	return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StaticTXT_FreePicCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_FreePic)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_ISOCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ISO)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_AntiShakingCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_AntiShaking)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_FDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_FD)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_DZoomCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_DZoom)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Battery)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
EVENT_END

//---------------------UIFlowWndPhoto_PNL_HistogramCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_Histogram)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_HistogramCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_Histogram)
EVENT_ITEM(NVTEVT_TIMER, UIFlowWndPhoto_PNL_Histogram_OnTimer)
EVENT_ITEM(NVTEVT_REDRAW, UIFlowWndPhoto_PNL_Histogram_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_Histogram_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_PNL_Histogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
//---------------------UIFlowWndPhoto_PNL_FDFrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_PNL_FDFrameCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
EVENT_ITEM(NVTEVT_REDRAW, UIFlowWndPhoto_PNL_FDFrame_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if _FD_FUNC_
#if (TV_FUNC == ENABLE)
	extern    DX_HANDLE gDevTVObj;
#endif
#if VDO_USE_ROTATE_BUFFER
	extern    DX_HANDLE gDevLCDObj;
	UINT32            isLCD = 0;
#endif
	UINT32            uiRectColor = _OSD_INDEX_WHITE;
	UINT32            i, Fdnumber;
	static FD_FACE    FdInfo[MAX_FDNUM];
	PDISP_OBJ         pDispObj = NULL;
	DISPLAYER_PARAM   DispLyr = {0} ;
	URECT             DispCord = {0, 0, 640, 480};
	UINT32            BorderW, BorderH = 3;
	ISIZE             dev1size;
	USIZE             dev1Ratio;
	UINT32            ExpandRatio = 1;

	//#NT#2016/08/18#Lincy Lin -begin
	//#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
	if (((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL) {
		return NVTEVT_CONSUME;
	}
	//#NT#2016/08/18#Lincy Lin -end

#if _TODO
	idec_setFDExpEn(0, 1);
#endif
	DispCord = pPhotoExeInfo->FdDispCoord;
#if (TV_FUNC == ENABLE)
	if (((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj) {
		ExpandRatio = 2;
	}
#endif
#if VDO_USE_ROTATE_BUFFER
	if (((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj) {
		isLCD = 1;
	}
#endif
	dev1size = GxVideo_GetDeviceSize(DOUT1);
	dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
	BorderW = dev1size.w / dev1Ratio.w * dev1Ratio.h * BorderH * ExpandRatio * 10 / dev1size.h;
	BorderW = ALIGN_ROUND(BorderW, 10) / 10;

	DBG_IND("[fd] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n", dev1size.w, dev1size.h, dev1Ratio.w, dev1Ratio.h, BorderW);
	DBG_IND("[fd] DispCord x=%d,y=%d, w=%d,h=%d \r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
	Fdnumber = FD_GetRsltFace(FdInfo, &DispCord);
	if (Fdnumber > MAX_FDNUM) {
		Fdnumber = MAX_FDNUM;
	}
	if (SysGetFlag(FL_FD) == FD_OFF) {
		uiRectColor = _OSD_INDEX_TRANSPART;
	} else {
		uiRectColor = _OSD_INDEX_WHITE;
	}

	DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n", uiRectColor);

	pDispObj = disp_getDisplayObject(DISP_1);
	for (i = 0; i < 16; i++) {
		DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0 << i;
		DispLyr.SEL.SET_FDEN.bEn = FALSE;
		pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
	}
	if (uiRectColor != _OSD_INDEX_TRANSPART) {
		for (i = 0; i < Fdnumber; i++) {
			// draw FD frame
			DBG_IND("[fd] %d ( %3d , %3d ; %3d , %3d )\r\n",
					i,
					FdInfo[i].x,
					FdInfo[i].y,
					FdInfo[i].w,
					FdInfo[i].h);

			pDispObj = disp_getDisplayObject(DISP_1);
			DispLyr.SEL.SET_FDSIZE.FD_NUM = DISPFD_NUM0 << i;
#if VDO_USE_ROTATE_BUFFER
			if (isLCD) {
				UINT32              /*in_hsz,*/ in_vsz;
				//in_hsz = dev1size.h;
				in_vsz = dev1size.w;
				DispLyr.SEL.SET_FDSIZE.uiFDX     = FdInfo[i].y;
				DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - FdInfo[i].w - FdInfo[i].x;
				DispLyr.SEL.SET_FDSIZE.uiFDW     = FdInfo[i].h;
				DispLyr.SEL.SET_FDSIZE.uiFDH     = FdInfo[i].w;
				DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
				DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;

				DBG_IND("[fd] rotate %d( %3d , %3d ; %3d , %3d )\r\n",
						i,
						DispLyr.SEL.SET_FDSIZE.uiFDX,
						DispLyr.SEL.SET_FDSIZE.uiFDY,
						DispLyr.SEL.SET_FDSIZE.uiFDW,
						DispLyr.SEL.SET_FDSIZE.uiFDH);
			} else
#endif
			{
				DispLyr.SEL.SET_FDSIZE.uiFDX = FdInfo[i].x * ExpandRatio;
				DispLyr.SEL.SET_FDSIZE.uiFDY = FdInfo[i].y;
				DispLyr.SEL.SET_FDSIZE.uiFDW = FdInfo[i].w * ExpandRatio;
				DispLyr.SEL.SET_FDSIZE.uiFDH = FdInfo[i].h;
				DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
				DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

			}
			DBG_IND("[fd] BorderW %d BorderH %d \r\n", DispLyr.SEL.SET_FDSIZE.uiFDBORD_W, DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
			pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

			DispLyr.SEL.SET_FDCOLOR.FD_NUM = DISPFD_NUM0 << i;
			DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
			DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
			DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
			pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

			DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0 << i;
			DispLyr.SEL.SET_FDEN.bEn = TRUE;
			pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
		}
	}
	pDispObj->load(TRUE);
#endif

	return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPhoto_StatusICN_ContinueShotCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ContinueShot)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_HDR)
EVENT_END

